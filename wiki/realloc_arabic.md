<!--
Meta Description: # إعادة تخصيص الذاكرة في C باستخدام الدالة realloc ## ملخص تعد دالة `realloc` في لغة C أداة قوية لإعادة تخصيص الذاكرة، حيث تتيح للمستخدم تغيير حجم الذ...
Meta Keywords: int, realloc, الذاكرة, array, إعادة
-->

# إعادة تخصيص الذاكرة في C باستخدام الدالة realloc

## ملخص
تعد دالة `realloc` في لغة C أداة قوية لإعادة تخصيص الذاكرة، حيث تتيح للمستخدم تغيير حجم الذاكرة المخصصة مسبقًا لنوع متغير محدد. تعتبر هذه الدالة مفيدة بشكل خاص عند الحاجة إلى تعديل حجم المصفوفات أو الهياكل الديناميكية.

## الوثائق
### الغرض
تستخدم دالة `realloc` لتغيير حجم الذاكرة المخصصة مسبقًا بواسطة دالة `malloc` أو `calloc` أو `realloc` نفسها. إذا كانت الذاكرة الجديدة أكبر من السابقة، يتم ملء الأجزاء الجديدة بالقيم الافتراضية. إذا كانت أصغر، يتم فقدان البيانات التي تتجاوز الحجم الجديد.

### الاستخدام
تكون الصيغة الأساسية لاستخدام `realloc` كالتالي:
```c
void* realloc(void* ptr, size_t new_size);
```

#### المعاملات:
- `ptr`: مؤشر إلى الذاكرة المخصصة مسبقًا. إذا كان `ptr` NULL، فإن `realloc` تعمل مثل `malloc` وتخصص الذاكرة جديدة.
- `new_size`: الحجم الجديد المطلوب (بالبايت) للذاكرة.

#### القيمة المرجعة:
- ترجع `realloc` مؤشرًا جديدًا للذاكرة المخصصة. إذا فشلت عملية إعادة التخصيص، ستعيد `NULL` مع الاحتفاظ بالمؤشر القديم.

### التفاصيل
عند استخدام `realloc`، يجب التأكد من التعامل مع حالة الفشل بشكل صحيح، حيث يمكن أن يؤدي إلى تسرب الذاكرة إذا لم يتم الاحتفاظ بالمؤشر القديم. يُفضل دائمًا استخدام متغير مؤقت لتخزين النتيجة.

## الأمثلة
### مثال 1: إعادة تخصيص مصفوفة
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int* array = (int*)malloc(5 * sizeof(int));
    for (int i = 0; i < 5; i++) {
        array[i] = i + 1;
    }

    // إعادة تخصيص المصفوفة لحجم أكبر
    int* new_array = (int*)realloc(array, 10 * sizeof(int));
    if (new_array == NULL) {
        free(array);
        printf("فشل إعادة التخصيص\n");
        return 1;
    }
    
    array = new_array;
    for (int i = 5; i < 10; i++) {
        array[i] = i + 1;
    }

    for (int i = 0; i < 10; i++) {
        printf("%d ", array[i]);
    }
    
    free(array);
    return 0;
}
```

### مثال 2: التعامل مع الفشل
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int* array = (int*)malloc(5 * sizeof(int));
    // محاولة إعادة تخصيص إلى حجم غير ممكن
    int* new_array = (int*)realloc(array, SIZE_MAX);

    if (new_array == NULL) {
        printf("فشل إعادة التخصيص، الذاكرة غير كافية\n");
        free(array);
        return 1;
    }

    // استخدام new_array هنا

    free(new_array);
    return 0;
}
```

## الشرح
### الأخطاء الشائعة
- **فقدان البيانات**: عند تقليص حجم المصفوفة، يجب أن تكون حذرًا حيث قد تفقد البيانات في العناصر الزائدة.
- **تسرب الذاكرة**: إذا لم يتم حفظ نتيجة `realloc` في متغير جديد قبل التحقق من الفشل، قد تفقد المؤشر الأصلي وتفقد القدرة على تحرير الذاكرة.
- **NULL**: إذا كانت `realloc` ترجع `NULL`، يجب عدم استخدام `ptr` الأصلي لأنه لا يزال يشير إلى ذاكرة صالحة.

## ملخص في جملة واحدة
تتيح دالة `realloc` في C إعادة تخصيص الذاكرة الديناميكية، مما يوفر مرونة في إدارة الذاكرة وتعديل حجم البيانات بشكل ديناميكي.